{"version":3,"sources":["../planner.js"],"names":["errors","TOO_MANY_GUESTS","IMPOSSIBLE_POSITIVE","IMPOSSIBLE_NEGATIVE","IMPOSSIBLE","POSITIVE_UNSATISFIED","NEGATIVE_UNSATISFIED","Planner","plan","guests","tableSize","tableCount","positive","negative","generationSize","generationCount","validateGuests","groupGuests","validateGroups","groupNegative","solution","solve","validate","a","b","groups","length","id","Math","floor","gNegativeSet","has","negToID","handled","Set","guest","group","exploreGroup","push","add","pos","one","two","lookup","Object","create","i","g1","g2","gNegative","con","idToNeg","generation","Array","fill","map","tables","randomArrangement","score","genIndex","concat","descendant","sort","splice","ex","table","g","remaining","tries","randomInsert","r","random","capacity","possibles","filter","max","reduce","item","mutation","problems","j","isNeg","problem","size","guestToTable","neg","planner","console","log"],"mappings":"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","file":"planner.js","sourcesContent":["import plan from './plan';\n\nconst errors = {\n    TOO_MANY_GUESTS: \"TOO_MANY_GUESTS\",\n    IMPOSSIBLE_POSITIVE: \"IMPOSSIBLE_POSITIVE\",\n    IMPOSSIBLE_NEGATIVE: \"IMPOSSIBLE_NEGATIVE\",\n\n    IMPOSSIBLE: \"IMPOSSIBLE\",\n    POSITIVE_UNSATISFIED: \"POSITIVE_UNSATISFIED\",\n    NEGATIVE_UNSATISFIED: \"NEGATIVE_UNSATISFIED\"\n};\n\nclass Planner\n{\n    constructor(plan){\n        this.guests = plan.guests;\n        this.tableSize = plan.tableSize;\n        this.tableCount = plan.tableCount;\n        this.positive = plan.positive;\n        this.negative = plan.negative;\n    }\n\n    plan(generationSize=25, generationCount=1000){\n        this.validateGuests();\n        this.groupGuests();\n        this.validateGroups();\n        this.groupNegative();\n        let solution = this.solve(generationSize, generationCount);\n        this.validate(solution);\n        return solution;\n    }\n\n    negToID(a, b){\n        return a + b * this.groups.length;\n    }\n    idToNeg(id){\n        return [id % this.groups.length, Math.floor(id / this.groups.length)];\n    }\n    isNeg(a, b){\n        return this.gNegativeSet.has(this.negToID(a, b));\n    }\n\n    validateGuests(){\n        if(this.guests.length > this.tableSize * this.tableCount)\n            throw errors.TOO_MANY_GUESTS;\n    }\n    groupGuests(){\n        let handled = new Set();\n        this.groups = [];\n\n        for(let guest of this.guests){\n            if(handled.has(guest))\n                continue;\n            let group = [];\n            this.exploreGroup(group, handled, guest);\n            this.groups.push(group);\n        }\n    }\n    exploreGroup(group, handled, guest){\n        group.push(guest);\n        handled.add(guest);\n        for(let pos of this.positive){\n            let [one, two] = pos;\n            if(guest === two)\n                [one, two] = [two, one];\n            if(guest === one && !handled.has(two))\n                this.exploreGroup(group, handled, two);\n        }\n    }\n    validateGroups(){\n        for(let group of this.groups){\n            if(group.length > this.tableSize)\n                throw errors.IMPOSSIBLE_POSITIVE;\n        }\n    }\n    groupNegative(){\n        let lookup = Object.create(null);\n        let i = 0;\n        for(let group of this.groups){\n            for(let guest of group)\n                lookup[guest] = i;\n            i++;\n        }\n        this.gNegativeSet = new Set();\n\n        for(let negative of this.negative){\n            let g1 = lookup[negative[0]];\n            let g2 = lookup[negative[1]];\n            if(g1 === g2)\n                throw errors.IMPOSSIBLE_NEGATIVE;\n            if(g1 > g2)\n                [g1, g2] = [g2, g1];\n            this.gNegativeSet.add(this.negToID(g1, g2));\n        }\n\n        this.gNegative = [];\n        for(let con of this.gNegativeSet)\n            this.gNegative.push(this.idToNeg(con));\n    }\n    solve(generationSize, generationCount){\n        let solution = null;\n        try{\n            let generation = new Array(generationSize).fill(null)\n                .map(() => {\n                    let tables = this.randomArrangement();\n                    let score = this.score(tables);\n                    return {tables, score};\n                });\n            let genIndex = 0;\n\n            while(++genIndex < generationCount){\n                generation = generation.concat(new Array(generationSize).fill(null)\n                    .map(() => {\n                        let tables = this.descendant(generation);\n                        let score = this.score(tables);\n                        return {tables, score};\n                    }));\n                generation.sort((a, b) => {\n                    if(a.score > b.score)\n                        return -1;\n                    else\n                        return 1;\n                });\n                generation.splice(generationSize, generationSize);\n            }\n\n            solution = generation[0];\n\n        }catch(ex){\n            if(ex instanceof Array)\n                solution = ex;\n            else\n                throw ex;\n        }\n        return solution.map(table => [].concat(...table.map(g => this.groups[g])));\n    }\n    capacity(table){\n        let remaining = this.tableSize;\n        for(let i of table)\n            remaining -= this.groups[i].length;\n        return remaining;\n    }\n    randomArrangement(){\n        let tries = 10;\n        while(tries-- > 0){\n            try{\n                let tables = new Array(this.tableCount).fill(null).map(() => []);\n                for(let i = 0; i < this.groups.length; i++)\n                    this.randomInsert(i, tables);\n                return tables;\n            }catch(ex){\n                if(ex !== 'impossible')\n                    throw ex;\n            }\n        }\n        throw errors.IMPOSSIBLE;\n    }\n    randomInsert(group, tables){\n        let r = Math.floor(Math.random() * this.tableCount);\n        if(this.capacity(tables[r]) >= this.groups[group].length){\n            tables[r].push(group);\n        }else{\n            let possibles = tables.filter(table => this.capacity(table) >= this.groups[group].length);\n            if(possibles.length === 0)\n                throw 'impossible';\n            r = Math.floor(Math.random() * possibles.length);\n            possibles[r].push(group);\n        }\n    }\n    descendant(generation){\n        let max = generation.reduce((a, item) => a + item.score, 0);\n        let tries = 10;\n        while(tries-- > 0){\n            try{\n                let r = Math.floor(Math.random() * max) + 1;\n                let tables;\n                for(let item of generation){\n                    r -= item.score;\n                    if(r <= 0){\n                        tables = item.tables;\n                        break;\n                    }\n                }\n                return this.mutation(tables);\n            }catch(ex){\n                if(ex !== 'impossible')\n                    throw ex;\n            }\n        }\n        throw errors.IMPOSSIBLE;\n    }\n    mutation(tables){\n        let tries = 3;\n        while(tries-- > 0){\n            try{\n                tables = tables.map(table => [...table]);\n                let problems = [];\n                for(let table of tables){\n                    for(let i = 0; i < table.length; i++)\n                        for(let j = i + 1; j < table.length; j++)\n                        {\n                            if(this.isNeg(table[i], table[j]))\n                            {\n                                problems.push(table[i], table[j]);\n                                table.splice(j, 1);\n                                table.splice(i, 1);\n                                i--;\n                                break;\n                            }\n                        }\n                }\n                let r = Math.random() * (this.groups.length - problems.length);\n                let i = 0;\n                for(let table of tables)\n                {\n                    if(r < table.length){\n                        let group = table.splice(r, 1)[0];\n                        do\n                        {\n                            r = Math.random() * tables.length;\n                        }while(r === i);\n                        tables[r].push(group);\n                    }\n                    r -= table.length;\n                    i++;\n                }\n                for(let problem of problems)\n                    this.randomInsert(problem, tables);\n                return tables;\n            }catch(ex){\n                if(ex !== 'impossible')\n                    throw ex;\n            }\n        }\n        throw 'impossible';\n    }\n    score(tables){\n        let score = this.gNegativeSet.size;\n        for(let table of tables){\n            for(let i = 0; i < table.length; i++)\n            for(let j = i + 1; j < table.length; j++)\n            {\n                if(this.isNeg(table[i], table[j])){\n                    score--;\n                }\n            }\n        }\n        if(score === this.gNegativeSet.size)\n            throw tables;\n        return score + 1;\n    }\n\n    validate(tables){\n        let guestToTable = Object.create(null);\n        let i = 0;\n        for(let table of tables)\n        {\n            for(let guest of table)\n                guestToTable[guest] = i;\n            i++;\n        }\n        for(let pos of this.positive)\n        {\n            if(guestToTable[pos[0]] !== guestToTable[pos[1]])\n                throw errors.POSITIVE_UNSATISFIED;\n        }\n        for(let neg of this.negative)\n        {\n            if(guestToTable[neg[0]] === guestToTable[neg[1]])\n                throw errors.NEGATIVE_UNSATISFIED;\n        }\n    }\n}\n\nlet planner = new Planner(plan);\nconsole.log(planner.plan());"]}